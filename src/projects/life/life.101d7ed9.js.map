{"version":3,"sources":["life.js"],"names":["c","document","getElementById","ctx","getContext","cells","h","w","state","steps","speed","height","window","innerHeight","width","innerWidth","init","i","j","draw","update","result","val","x","y","forEach","row","cell","neighbors","amount","check","clearRect","fillStyle","fillRect","font","fillText","setTimeout","addEventListener","e","Math","floor","offsetX","offsetY","console","log","code"],"mappings":";AAGA,IAAMA,EAAIC,SAASC,eAAe,UAC5BC,EAAMH,EAAEI,WAAW,MACrBC,EAAQ,GACRC,EAAIC,EAAI,GACRC,GAAQ,EACRC,EAAQ,EACRC,EAAQ,GAEZV,EAAEW,OAASC,OAAOC,YAClBb,EAAEc,MAAQF,OAAOG,WAEjB,IAAMC,EAAO,WACN,IAAA,IAAIC,EAAI,EAAGA,EAAIjB,EAAEW,OAASL,EAAGW,IAAK,CACrCZ,EAAMY,GAAK,GACP,IAAA,IAAIC,EAAI,EAAGA,EAAIlB,EAAEc,MAAQP,EAAGW,IAC9Bb,EAAMY,GAAGC,GAAK,EAIlBC,KAGIC,EAAS,WAEPC,IAAAA,EAAS,GAETC,EAAM,SAACC,EAAGC,GAAMnB,OAAAA,EAAMkB,IAAMlB,EAAMkB,GAAGC,IAmB3CnB,EAAMoB,QAAQ,SAACC,EAAKH,GAClBF,EAAOE,GAAK,GACZG,EAAID,QAAQ,SAACE,EAAMH,GACbI,IAAAA,EAnBM,SAACL,EAAGC,GACZK,IAAAA,EAAS,EAWNA,OATJP,EAAIC,EAAE,EAAGC,EAAE,IAAIK,IACfP,EAAIC,EAAGC,EAAE,IAAIK,IACbP,EAAIC,EAAE,EAAGC,EAAE,IAAIK,IACfP,EAAIC,EAAE,EAAGC,IAAIK,IACbP,EAAIC,EAAE,EAAGC,IAAIK,IACbP,EAAIC,EAAE,EAAGC,EAAE,IAAIK,IACfP,EAAIC,EAAGC,EAAE,IAAIK,IACbP,EAAIC,EAAE,EAAGC,EAAE,IAAIK,IAEXA,EAOWC,CAAMP,EAAGC,GAGrBH,EAAOE,GAAGC,GAFVG,EACgB,IAAdC,GAAiC,IAAdA,EACN,EAGA,EAIC,IAAdA,EACa,EAEG,MAM1BvB,EAAQgB,EAERZ,IACAU,KAGIA,EAAO,SAAPA,IAEJhB,EAAI4B,UAAU,EAAE,EAAE/B,EAAEc,MAAMd,EAAEW,QAG5BN,EAAMoB,QAAQ,SAACC,EAAKF,GAClBE,EAAID,QAAQ,SAACE,EAAMJ,GACjBpB,EAAI6B,UAAYL,EAAO,UAAY,UACnCxB,EAAI8B,SAASV,EAAEhB,EAAE,EAAEiB,EAAElB,EAAE,EAAEC,EAAE,EAAED,EAAE,OAKnCH,EAAI6B,UAAY,QAChB7B,EAAI8B,SAASjC,EAAEc,MAAQ,IAAI,EAAEd,EAAEc,MAAO,IACtCX,EAAI+B,KAAO,kBACX/B,EAAIgC,SAAgC,sBAAA,GAAI,IACxChC,EAAIgC,SAAuB,aAAA,GAAI,IAC/BhC,EAAI6B,UAAY,QAChB7B,EAAI+B,KAAO,kBACX/B,EAAIgC,SAAwB1B,eAAAA,OAAAA,GAAST,EAAEc,MAAQ,IAAK,IAGpDsB,WAAW,WACL5B,EACFY,IAGAD,KAEDT,IAILV,EAAEqC,iBAAiB,YAAa,SAASC,GACjCf,IAAAA,EAAIgB,KAAKC,MAAMF,EAAEG,QAAQlC,GACzBiB,EAAIe,KAAKC,MAAMF,EAAEI,QAAQpC,GAC/BD,EAAMmB,GAAGD,GAAKlB,EAAMmB,GAAGD,GAAK,EAAI,IAIlCX,OAAOyB,iBAAiB,UAAW,SAASC,GAEnCA,OADPK,QAAQC,IAAIN,EAAEO,MACPP,EAAEO,MACF,IAAA,QACHrC,GAASA,EACT,MACG,IAAA,OACHA,GAAQ,EACRC,EAAQ,EACRO,OAKNJ,OAAOyB,iBAAiB,SAAU,WAChCrC,EAAEW,OAASC,OAAOC,YAClBb,EAAEc,MAAQF,OAAOG,WAEjBP,GAAQ,EACRC,EAAQ,EACRO,MAGFA","file":"life.101d7ed9.js","sourceRoot":"..","sourcesContent":["// Life\n// Â© 2015-2020 Michael Hamilton\n\nconst c = document.getElementById('canvas');//canvas element\nconst ctx = c.getContext('2d'); //canvas context\nlet cells = []; //arr\nlet h = w = 12; //dimensions of each cell (in px)\nlet state = false; //current state of game (draw or update)\nlet steps = 0; //current number of cycles\nlet speed = 10; //current number of cycles\n\nc.height = window.innerHeight;\nc.width = window.innerWidth;\n\nconst init = () => {\n  for (let i = 0; i < c.height / h; i++) {\n    cells[i] = []\n    for(let j = 0; j < c.width / w; j++) {\n      cells[i][j] = 0;\n    }\n  }\n\n  draw();\n}\n\nconst update = () => {\n  //Temporary array for state of cells in next cycle\n  const result = [];\n\n  const val = (x, y) => cells[x] && cells[x][y];\n\n  //Returns amount of neighbor cells that are active\n  const check = (x, y) => {\n    let amount = 0;\n\n    if(val(x-1, y-1)) amount++;\n    if(val(x, y-1)) amount++;\n    if(val(x+1, y-1)) amount++;\n    if(val(x-1, y)) amount++;\n    if(val(x+1, y)) amount++;\n    if(val(x-1, y+1)) amount++;\n    if(val(x, y+1)) amount++;\n    if(val(x+1, y+1)) amount++;\n\n    return amount;\n  }\n\n  //Check each cell and update the result array\n  cells.forEach((row, x) => {\n    result[x] = [];\n    row.forEach((cell, y) => {\n      let neighbors = check(x, y);\n      if (cell) {\n        if (neighbors === 2 || neighbors === 3) {\n          result[x][y] = 1;\n        }\n        else {\n          result[x][y] = 0;\n        }\n      }\n      else {\n        if (neighbors === 3) {\n          result[x][y] = 1;\n        }\n        else result[x][y] = 0;\n      }\n    });\n  });\n\n  //Copy temporary array back to cells\n  cells = result;\n\n  steps ++;\n  draw();\n}\n\nconst draw = () => {\n  //Clear last frame\n  ctx.clearRect(0,0,c.width,c.height);\n\n  //Draw the cells in the current cycle\n  cells.forEach((row, y) => {\n    row.forEach((cell, x) => {\n      ctx.fillStyle = cell ? \"#0a90ff\" : '#d7d7d7';\n      ctx.fillRect(x*w+1,y*h+1,w-1,h-1);\n    });\n  });\n\n  //Update step counter\n  ctx.fillStyle = 'black';\n  ctx.fillRect(c.width - 200,0,c.width, 24);\n  ctx.font = '18px sans-serif';\n  ctx.fillText(`Space to play/pause`, 10, 20);\n  ctx.fillText(`R to reset`, 10, 40);\n  ctx.fillStyle = 'white';\n  ctx.font = '18px sans-serif';\n  ctx.fillText(`Generation: ${steps}`, c.width - 190, 18);\n\n  //Update every n number of ms as defined by 'speed'\n  setTimeout(() => {\n    if (state) {\n      update();\n    }\n    else {\n      draw();\n    }\n  }, speed);\n}\n\n//Toggle the cell at cursor position when canvas is clicked\nc.addEventListener('mousedown', function(e) {\n  const x = Math.floor(e.offsetX/w);\n  const y = Math.floor(e.offsetY/h);\n  cells[y][x] = cells[y][x] ? 0 : 1;\n});\n\n//Start game when 'space' is pressed\nwindow.addEventListener('keydown', function(e) {\n  console.log(e.code);\n  switch(e.code) {\n    case 'Space':\n      state = !state;\n      break;\n    case 'KeyR':\n      state = false;\n      steps = 0;\n      init();\n      break;\n  }\n});\n\nwindow.addEventListener('resize', () => {\n  c.height = window.innerHeight;\n  c.width = window.innerWidth;\n\n  state = false;\n  steps = 0;\n  init();\n});\n\ninit();\n"]}