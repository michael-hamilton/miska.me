{"version":3,"sources":["life.js"],"names":["c","document","getElementById","ctx","getContext","cells","isRunning","isUpdating","updateTimeout","h","w","delay","steps","init","y","height","x","width","update","nextGeneration","cellValueAtCoordinate","forEach","row","cell","neighbors","active","check","drawText","fillStyle","font","fillText","fillRect","draw","clearRect","setTimeout","requestAnimationFrame","handleReset","clearTimeout","window","innerHeight","innerWidth","addEventListener","e","Math","floor","offsetX","offsetY","code"],"mappings":"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","file":"life.81214d40.js","sourceRoot":"..","sourcesContent":["// Game of Life\n// Â© 2015-2020 Michael Hamilton\n\nconst c = document.getElementById('canvas');// canvas element\nconst ctx = c.getContext('2d'); // canvas context\nlet cells = []; // all the cells in the simulation\nlet isRunning = false; // running state of the simulation\nlet isUpdating = false; // simulation is updating\nlet updateTimeout = false; // reference to timeout between updates\nlet h = w = 12; // dimensions of each cell (in px)\nlet delay = 10; // current number of cycles\nlet steps = 0; // current number of cycles\n\n// Initializes grid cells based on size of window\nconst init = () => {\n  for (let y = 0; y < c.height / h; y++) {\n    cells[y] = []\n    for (let x = 0; x < c.width / w; x++) {\n      cells[y][x] = 0;\n    }\n  }\n}\n\n// Handle update between generations\nconst update = () => {\n  const nextGeneration = [];\n\n  const cellValueAtCoordinate = (x, y) => cells[x] && cells[x][y];\n\n  // Returns number of active neighbor cells\n  const check = (x, y) => {\n    let active = 0;\n\n    if (cellValueAtCoordinate(x-1, y-1)) active++;\n    if (cellValueAtCoordinate(x, y-1)) active++;\n    if (cellValueAtCoordinate(x+1, y-1)) active++;\n    if (cellValueAtCoordinate(x-1, y)) active++;\n    if (cellValueAtCoordinate(x+1, y)) active++;\n    if (cellValueAtCoordinate(x-1, y+1)) active++;\n    if (cellValueAtCoordinate(x, y+1)) active++;\n    if (cellValueAtCoordinate(x+1, y+1)) active++;\n\n    return active;\n  }\n\n  // Check each cell and update the result array\n  cells.forEach((row, x) => {\n    nextGeneration[x] = [];\n\n    row.forEach((cell, y) => {\n      let neighbors = check(x, y);\n\n      if (cell) {\n        if (neighbors === 2 || neighbors === 3) {\n          nextGeneration[x][y] = 1;\n        }\n        else {\n          nextGeneration[x][y] = 0;\n        }\n      }\n      else {\n        if (neighbors === 3) {\n          nextGeneration[x][y] = 1;\n        }\n        else nextGeneration[x][y] = 0;\n      }\n    });\n  });\n\n  // Copy temporary array back to cells\n  cells = [...nextGeneration];\n}\n\n// Draw title, instructions, etc\nconst drawText = () => {\n  ctx.fillStyle = 'black';\n  ctx.font = '24px sans-serif';\n  ctx.fillText('Game of Life', 10, 20);\n  ctx.font = \"14px sans-serif\";\n  ctx.fillText('click cells to toggle on and off', 10, 45);\n  ctx.fillText('space to play/pause', 10, 65);\n  ctx.fillText('up/down to change delay between generations', 10, 85);\n  ctx.fillText('R to reset', 10, 105);\n\n  ctx.fillRect(c.width - 200,0,c.width, 50);\n  ctx.fillStyle = 'white';\n  ctx.font = '18px sans-serif';\n  ctx.fillText(`Generation: ${steps}`, c.width - 190, 18);\n  ctx.fillText(`Delay: ${delay}`, c.width - 190, 38);\n}\n\n// Main loop\nconst draw = () => {\n  //Clear last frame\n  ctx.clearRect(0,0,c.width,c.height);\n\n  //Draw the cells in the current cycle\n  cells.forEach((row, y) => {\n    row.forEach((cell, x) => {\n      ctx.fillStyle = cell ? \"#0a90ff\" : '#d7d7d7';\n      ctx.fillRect(x*w+1,y*h+1,w-1,h-1);\n    });\n  });\n\n  drawText();\n\n  // Update every 'delay' ms\n  if (isRunning && !isUpdating) {\n    isUpdating = true;\n    updateTimeout = setTimeout(() => {\n      isUpdating = false;\n      update();\n      steps++;\n    }, delay);\n  }\n\n  requestAnimationFrame(draw);\n}\n\n// Reset simulation\nconst handleReset = () => {\n  clearTimeout(updateTimeout);\n  c.height = window.innerHeight;\n  c.width = window.innerWidth;\n  isRunning = false;\n  isUpdating = false;\n  steps = 0;\n  init();\n};\n\n// Toggle the cell at cursor position when canvas is clicked\nc.addEventListener('mousedown', (e) => {\n  const x = Math.floor(e.offsetX/w);\n  const y = Math.floor(e.offsetY/h);\n  cells[y][x] = cells[y][x] ? 0 : 1;\n});\n\n// Handle keyboard events\nwindow.addEventListener('keydown', (e) => {\n  switch(e.code) {\n    case 'Space':\n      isRunning = !isRunning;\n      break;\n    case 'KeyR':\n      handleReset();\n      break;\n    case 'ArrowUp':\n      delay += 1;\n      break;\n    case 'ArrowDown':\n      delay -= delay > 0 ? 1 : 0;\n      break;\n  }\n});\n\n// Reset simulation when window is resized\nwindow.addEventListener('resize', handleReset);\n\nc.height = window.innerHeight;\nc.width = window.innerWidth;\n\ninit();\ndraw();\n"]}